import { describe, it, expect } from 'vitest';
import { render, screen, act } from '@testing-library/react';
import { renderHook } from '@testing-library/react';
import React from 'react';
import { MessageProvider, useMessages, MessageContext } from '../MessageProvider';

describe('MessageProvider', () => {
  describe('rendering', () => {
    it('renders children', () => {
      render(
        <MessageProvider>
          <div data-testid="child">Child content</div>
        </MessageProvider>
      );

      expect(screen.getByTestId('child')).toBeInTheDocument();
    });

    it('provides context to children', () => {
      const TestComponent = () => {
        const messages = useMessages();
        return <div data-testid="has-context">{messages ? 'yes' : 'no'}</div>;
      };

      render(
        <MessageProvider>
          <TestComponent />
        </MessageProvider>
      );

      expect(screen.getByTestId('has-context')).toHaveTextContent('yes');
    });
  });

  describe('useMessages hook', () => {
    it('returns undefined when used outside provider', () => {
      const { result } = renderHook(() => useMessages());
      expect(result.current).toBeUndefined();
    });

    it('returns messages context when used inside provider', () => {
      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <MessageProvider>{children}</MessageProvider>
      );

      const { result } = renderHook(() => useMessages(), { wrapper });

      expect(result.current).toBeDefined();
      expect(result.current?.messages).toEqual([]);
      expect(typeof result.current?.sendMessage).toBe('function');
      expect(typeof result.current?.clearMessage).toBe('function');
    });
  });

  describe('sendMessage', () => {
    it('adds message to messages array', () => {
      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <MessageProvider>{children}</MessageProvider>
      );

      const { result } = renderHook(() => useMessages(), { wrapper });

      act(() => {
        result.current?.sendMessage({
          message: 'Test message',
          variant: 'info',
        });
      });

      expect(result.current?.messages).toHaveLength(1);
      expect(result.current?.messages[0].message).toBe('Test message');
      expect(result.current?.messages[0].variant).toBe('info');
    });

    it('auto-generates key when not provided', () => {
      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <MessageProvider>{children}</MessageProvider>
      );

      const { result } = renderHook(() => useMessages(), { wrapper });

      act(() => {
        result.current?.sendMessage({
          message: 'Test message',
          variant: 'success',
        });
      });

      expect(result.current?.messages[0].key).toMatch(/^autogenerated-message\d+$/);
    });

    it('uses provided key when given', () => {
      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <MessageProvider>{children}</MessageProvider>
      );

      const { result } = renderHook(() => useMessages(), { wrapper });

      act(() => {
        result.current?.sendMessage({
          key: 'custom-key',
          message: 'Test message',
          variant: 'warning',
        });
      });

      expect(result.current?.messages[0].key).toBe('custom-key');
    });

    it('replaces message with same key', () => {
      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <MessageProvider>{children}</MessageProvider>
      );

      const { result } = renderHook(() => useMessages(), { wrapper });

      act(() => {
        result.current?.sendMessage({
          key: 'same-key',
          message: 'First message',
          variant: 'info',
        });
      });

      act(() => {
        result.current?.sendMessage({
          key: 'same-key',
          message: 'Updated message',
          variant: 'success',
        });
      });

      expect(result.current?.messages).toHaveLength(1);
      expect(result.current?.messages[0].message).toBe('Updated message');
      expect(result.current?.messages[0].variant).toBe('success');
    });

    it('adds multiple messages with different keys', () => {
      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <MessageProvider>{children}</MessageProvider>
      );

      const { result } = renderHook(() => useMessages(), { wrapper });

      act(() => {
        result.current?.sendMessage({
          key: 'key1',
          message: 'Message 1',
          variant: 'info',
        });
      });

      act(() => {
        result.current?.sendMessage({
          key: 'key2',
          message: 'Message 2',
          variant: 'warning',
        });
      });

      expect(result.current?.messages).toHaveLength(2);
    });

    it('supports all message variants', () => {
      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <MessageProvider>{children}</MessageProvider>
      );

      const { result } = renderHook(() => useMessages(), { wrapper });

      const variants: Array<'success' | 'info' | 'warning' | 'danger'> = [
        'success',
        'info',
        'warning',
        'danger',
      ];

      variants.forEach((variant, index) => {
        act(() => {
          result.current?.sendMessage({
            key: `key-${index}`,
            message: `${variant} message`,
            variant,
          });
        });
      });

      expect(result.current?.messages).toHaveLength(4);
    });

    it('supports optional title and icon', () => {
      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <MessageProvider>{children}</MessageProvider>
      );

      const { result } = renderHook(() => useMessages(), { wrapper });

      act(() => {
        result.current?.sendMessage({
          key: 'with-title',
          title: 'Alert Title',
          message: 'Message with title',
          variant: 'info',
        });
      });

      expect(result.current?.messages[0].title).toBe('Alert Title');
    });
  });

  describe('clearMessage', () => {
    it('removes message by key', () => {
      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <MessageProvider>{children}</MessageProvider>
      );

      const { result } = renderHook(() => useMessages(), { wrapper });

      act(() => {
        result.current?.sendMessage({
          key: 'to-remove',
          message: 'Will be removed',
          variant: 'info',
        });
      });

      expect(result.current?.messages).toHaveLength(1);

      act(() => {
        result.current?.clearMessage('to-remove');
      });

      expect(result.current?.messages).toHaveLength(0);
    });

    it('only removes message with matching key', () => {
      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <MessageProvider>{children}</MessageProvider>
      );

      const { result } = renderHook(() => useMessages(), { wrapper });

      // Add messages in separate acts to avoid stale closure issues
      act(() => {
        result.current?.sendMessage({
          key: 'keep',
          message: 'Keep this',
          variant: 'info',
        });
      });

      act(() => {
        result.current?.sendMessage({
          key: 'remove',
          message: 'Remove this',
          variant: 'warning',
        });
      });

      expect(result.current?.messages).toHaveLength(2);

      act(() => {
        result.current?.clearMessage('remove');
      });

      expect(result.current?.messages).toHaveLength(1);
      expect(result.current?.messages[0].key).toBe('keep');
    });

    it('does nothing when key not found', () => {
      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <MessageProvider>{children}</MessageProvider>
      );

      const { result } = renderHook(() => useMessages(), { wrapper });

      act(() => {
        result.current?.sendMessage({
          key: 'existing',
          message: 'Existing message',
          variant: 'info',
        });
      });

      act(() => {
        result.current?.clearMessage('non-existent');
      });

      expect(result.current?.messages).toHaveLength(1);
    });
  });
});
